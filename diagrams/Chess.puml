@startuml
'https://plantuml.com/class-diagram

'enum Color {
'WHITE
'BLACK
'}

enum Player {
    BLACK
    WHITE
}

class Game {
    - gameRules: GameRules
    - gameBoard: GameBoard
    - validator: MoveValidator
    - currentTurn: Player
    ' isMovable would be used in movePiece(): it permits, for instance, to block the rival's pieces, or piece movements when the player's king is checked.
    + movePiece(String from, String to)
}

interface InputProvider {
    + requestPlayerMove(player: Player): String
}

interface TurnManager {
    + getTurn(): Player
    + nextTurn(): TurnManager
}

interface GameRules {
    + isPieceMovable(String position): boolean
    + isMoveValid(String from, String to): boolean
    + playerReachedWinCondition(Player player)
    + playerIsChecked(Player player)
}

interface GameBoard {
    + isOccupied(String position): boolean
    + getPieceAt(String position): Piece
    + setPieceAt(String position, Piece piece): GameBoard
    + detPieceAt(String position): GameBoard
    + positionExists(String position): boolean
    + containsPieceOfPlayer(String position, Player player): boolean
    + getAllPiecesOfPlayer(Player player): Iterable<Piece>
}

'interface MoveValidator {
'    + isPieceMovable(String position): boolean
'    + isMoveValid(String from, String to): boolean
'    'TODO: Maybe instead have a method that gets all movable pieces? Or maybe isMovable() should support polymorphism by Piece. In that case, it should be a method of that interface.
'}

class HashGameBoard implements GameBoard {
    - squares: HashMap<String, Piece>
    - validator: PositionValidator
    + isOccupied(String position): boolean
    + getPieceAt(String position): Piece
    + detPieceAt(String position, Piece piece): GameBoard
    + detPieceAt(String position): GameBoard
    + positionExists(String position): boolean
    + containsPieceOfPlayer(String position, Player player): boolean
    + getAllPiecesOfPlayer(Player player): Iterable<Piece>
    + unpackPosition(position: String): RowAndCol
    + getRowAsWhite(position: String, player: Player): Int
}

interface PositionValidator {
    ' Allows to define different kinds of game board
    + positionExists(): boolean
}

class RectangleBoardValidator implements PositionValidator {
    - numOfRows: int
    + positionExists(): boolean
    + getRowAsWhite(): Int
    + unpackPosition(position: String): RowAndCol
}

'class Square {
'    - x: Character
'    - y: int
'    - pieceOccupying: Piece
'
'    + getX(): Character
'    + getY(): int
'    + isOccupied(): boolean
'    + getPieceOccupying(): Piece
'}

'interface Rule {
'    + isViolated(Square currSquare, Square newSquare): boolean
'}

'class BoardLimitsRule implements Rule {
'}

'class RuleSet implements Rule {
'    - rules: Iterable<Rule>
'    + isViolated(Square currSquare, Square newSquare): boolean
'}

'class MoveRuleSet {
'
'    + getValidMoves(): Iterable<String>
'}

'class MoveFilter {
'}

' class PawnMove implements Rule {
'   boolean isViolated(Square currSquare, Square newSquare) {
'       return currSquare.y == newSquare.y + 1;
'   }
'}
'
' class
'
'

class Play implements Action {
    - board: GameBoard
    - actions: Iterable<Action>
    + execute(): void
}

interface Action {
    + execute(): GameBoard
}

class Move implements Action {
    - from: String
    - to: String
    - board: GameBoard
    - pieceNextTurn: Piece
    + execute(): GameBoard
}

class Take implements Action {
    - position: String
    - board: GameBoard
    + execute(): GameBoard
    ' TODO: Sometimes moving our piece implicitly includes taking the rival's piece (we reassign the latter's board position to the former, so the reference is replaced). Think about this.
}

class Promote implements Action {
    - position: String
    - promotionPiece: Class
    - board: GameBoard
    + execute(): GameBoard
}

class Piece {
    - player: Player
    - rules: PieceRules
    + getPlayer(): Player
    + getRules(): PieceRules
}

interface PieceRules {
    + isPlayValid(): boolean
    + getValidPlays(): Set<Play>
    + getPlayIfValid() Play
}

class KingPieceRules implements PieceRules {
    - player: Player
    + isPlayValid(): boolean
    + getValidPlays(): Set<Play>
    + getPlayIfValid() Play
    + isChecked(board: GameBoard): Boolean
}

enum Path {
    VERTICAL_AND_HORIZONTAL,
    DIAGONAL,
    ANY_STRAIGHT_LINE,
    L_SHAPED

    + isViolated(moveData: MovementData): Boolean
    + isPathBlocked(moveData: MovementData, board: GameBoard): boolean
    ' Checks whether something is blocking the path between a piece and a position.
}

class MovementData {
    + from: String
    + to: String
    + fromRow: Int
    + fromCol: Int
    + toRow: Int
    + toCol: Int
    + rowDelta: Int
    + colDelta: Int
}

'enum StandardPiece {
'    KING
'    ROOK
'    QUEEN
'    BISHOP
'    KNIGHT
'    PAWN
'
'    + getInstanceOf(StandardPiece piece, Player player)
'}

'class King extends Piece {
'    move(Square): void
'}
'class Rook extends Piece {
'    move(Square): void
'}
'class Bishop extends Piece {
'    move(Square): void
'}
'class Queen extends Piece {
'    move(Square): void
'}
'class Knight extends Piece {
'    move(Square): void
'}
'class Pawn extends Piece {
'    move(Square): void
'}

Game *--> GameRules
Game *-> GameBoard
Game *-> TurnManager
Game *-> Player
Game *-> InputProvider
'MoveValidator -> GameRules

GameRules o-> GameBoard
GameBoard *-> Piece
HashGameBoard *--> PositionValidator
'Piece -> MoveRuleSet
'RuleSet -> Rule
'Piece -> Rule
Piece *-> Player
Piece *-> PieceRules
PieceRules --> Path
PieceRules -> Play
Play *--> Action
Play *--> GameBoard
Path -> MovementData



'TODO: The fact that you cannot take your own pieces is a general rule. Check and checkmate are, too; even board-limit rules. Think about which general rules could be represented and how.


@enduml